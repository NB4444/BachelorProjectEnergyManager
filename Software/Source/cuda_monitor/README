#
# Compiling and execution instructions
#

There are two important files
	- libmonitor.so (requires CUDA and CUPTI)
	- monitor (requires CUDA and NVML)

The library is loaded next to the CUDA application. Just prints a sequence of
of CUDA calls and some related data. The monitor constantly prints the GPU/CPU
state. To compile the files just enter in src folder and type make. Before
that, you have to edit the CUDA and CUPTI (and maybe NVML) installation
paths inside the Makefile. After the make, both monitor and libmonitor.so will
be generated in src.

In the etc folder, there is an example of how to use the library. Before submitting
the application, start the monitor in the compute node. You have to
load the library using LD_PRELOAD. It doesn't need any initialization, it uses
a constructor to set the CUPTI callbacks.

For each test case, two files must be generated. One corresponding to the monitor
output and the other one for the library/application output. As the example below:

	./monitor &> app1.monitor.txt
	LD_PRELOAD=./libmonitor.so $application_path/cuda_application &> app1.libmonitor.txt

#
# Additional comments
#

The monitor creates a pipe in the folder, ignore this. It is just old code
and we are using a select with it to temporize the application sampling.
